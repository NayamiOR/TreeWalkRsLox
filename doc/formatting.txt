那么接下来我们要给Lox实现老式的经典C风格的For循环，如下所示。
在语法中，它是这样的。
经典的For循环有三条子句，由分号隔开。
第一条子句是初始化子句，它只会在循环开始前执行一次。
它通常是一个表达式，但我们也允许变量声明。
这里声明的变量的作用域范围就是这个循环的内部，以及另外两个子句的内部。
第二个子句是条件表达式，它的作用和while语句的子句一样。
它会在每次循环之前执行一次，如果结果是真，循环继续，否则循环结束。
最后一个子句是增量式，这是一个任意的表达式，在每次循环之后执行。
因为表达式的结果会被丢弃，所以它通常会产生一些副作用。
它最常见的用法是每次循环递增一个计数器。
三个子句都可以忽略，也就是不写。
右括号之后我们要读取一个语句，一般来说是一个代码块。
For循环的语法包含了很多功能，但是我们已有的功能是完全可以代替For循环的。
比如我们可以在while语句之前定义变量，然后再在循环的最后执行增量表达式。
For循环不是必要的，但是For循环可以简化很多常见的代码模式。
所以我们可以说For循环是一种语法糖，比如前面的例子我们可以写成这里这样。
虽然这样写别扭但是它和For循环是等价的。
这种语法糖特性可以让语言写起来更爽，
但在复杂的语言实现中给多一个语法特性进行优化的代价都很大。
所以这里我们用脱糖来实现For循环。
也就是说，前端接收使用了语法糖的代码，并将其转换成后端知道如何执行的更原始的形式。
我们的解释器要把For循环脱糖成类似这里演示的用while循环实现的例子中的样子。
所以我们这里并不会给For循环单独添加一个语法树节点。
现在我们来到Parser部分，我们在statement规则下新添加一个分支，匹配for循环。
这里我们和别的分支一样，调用一个ForStatement函数，并再下面定义并实现它。
刚才这里的匹配已经把For关键字消耗掉了，所以我们先往下把左括号消耗掉。
来到第一个子句，是初始化子句。
如果一上来直接找到分号了，说明就没给入初始化子句，初始化子句就为空。
如果找到var关键字了，说明找到了变量声明，我们就调用varDeclaration函数。
否则就读取一个表达式，这个表达式的结果会被丢弃。
无论是变量声明还是表达式，本质上都是语句，所以都会在最后消耗一个分号。
于是我们这里就没必要在另外消耗分号了。
然后来读条件子句，这里我们读的是一个表达式，所以最后我们要手动消耗一个分号。
到了增量子句，如果能匹配到右括号，说明没给增量子句，增量子句就为空。
对于增量子句我们选择读取一个表达式。
最后我们把右括号消耗掉，三个子句就搞定了。
往后我们再读一个语句，作为循环的主体。
到这一步为止我们已经把循环的每个部分都读取到手了，接下来就要开始脱糖了。
我们先从增量子句开始着手。
理论上来说增量子句会在每次循环中，在body运行结束之后运行。
所以我们把增量子句和原来的循环体打包进一个代码块中，用这个代码块替换原来的body。
这样我们的增量子句就可以在循环体运行一遍后运行了。
然后来处理条件表达式。
我们用while来构建循环，条件表达式可以直接用作while的条件。
如果没给条件表达式，那就默认为True。接着我们把原来的body作为while的循环体。
while循环就构建好了，最后我们在while循环的前面加上初始化语句就好了。
具体步骤和刚才一样。
通过这一系列操作，我们就把一个for循环给拆成了while循环。
比如说上面这条代码就被拆成了下面这样。
增量句被加入循环体内的末尾，条件句被作为while循环的条件，循环体照常。
最后初始化语句被放在while循环前面运行。
这就是我们脱糖For循环的全过程。脱糖使我们不需要处理解释器类就支持了For循环。
这里我还特地把表示作用域的大括号写的全了些，转换后的代码块本质上应该是类似这样的。
这里，for循环的作用域就是外部的这个大括号。
变量i被限制在了这个作用域里，所以不会污染外部环境。
原书给了一段测试代码，用于输出斐波那契数列的前22个元素。
那For循环的部分这里就结束了，接下来我们就要实现函数了，我们下期见。